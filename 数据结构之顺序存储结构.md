# 数据结构之顺序存储结构

时间复杂度（取决于阶乘最高的）

### 线性表的物理结构

1. #### 顺序存储结构

   数组的每一个元素在内存中相连

   优点：

   - 无须为表示元素逻辑关系增加额外的存储空间
   - 随机访问效率高#`时间复杂度O(1)`

   缺点：

   - 插入、删除元素需要移动大量元素，效率低#`时间复杂度O(N)`
   - 需要预先分配空间，线性表长度变化较大的时候难以确定存储空间的容量。分配大了浪费，分配小了容易溢出
   - 造成存储空间的碎片

   实现：数组

   TODO：ArrayList源码分析

2. #### 链式存储结构

   用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续。所以物理上是离线的，逻辑上是连续的。

   优点：

   - 头部插入、中间插入、删除元素效率高#`找到某位置的指针后，插入删除的时间复杂度仅为O(1)`
   - 不需要预分配空间，元素个数不受限

   缺点：

   - 不支持随机访问，需要轮询查找，效率低#`时间复杂度O(N)`

   实现：单链表、双链表、单向循环链表、双向循环链表

   TODO：LinkedList源码分析




`若线性表需要频繁查找，很少进行插入和删除操作，适合采用顺序存储结构。当需要进行频繁的插入删除时，适合采用链式存储结构；当线性表中元素个数变化较大时，适合采用链式存储结构`



### 链表的实现及翻转

[双向链表(Java)](https://github.com/lhc20040808/DataStructureJava/blob/master/src/LinkedList.java)

[单链表（c++）](https://github.com/lhc20040808/SummaryOfExperience/blob/master/算法：C%2B%2B单链表的实现及翻转.md)

链表翻转思路

1、创建新的链表，移动每个结点，链表支持头插则时间复杂度为O(N)，链表仅支持尾插则时间复杂度为O(N^2)。

2、就地翻转法，时间复杂度O(N)

```java
        Node p = first;//①记录原首结点
        while (p.next != null) {
            Node q = p.next;//②取出当前要翻转的结点
            p.next = p.next.next;//③原首结点指向翻转结点的下个结点
            q.next = first;//④翻转结点指向首结点
            q.prev = null;//⑤翻转结点上个结点指向当前首结点的上个结点
            first.prev = q;//⑥当前首结点上个结点置为翻转结点
            first = q;//⑦修改首结点位置，重复2-7
        }
```





### LinkedList源码简单分析

源码中也采用含有头尾指针的双向链表，检索时通过二分法优化了检索效率。同时实现了栈的push、pop、peek等方法。



#### ArrayList源码简单 分析

底层由数组实现，默认容量为10。当容量不够会进行扩容，扩容的比例`oldcapaCity + (oldCapacity >> 1)`。如果这个容量仍然不满足大小，则扩容后的容量为当前所需容量。插入、删除都需要移动元素，并且插入导致的扩容需要进行元素拷贝，消耗资源。